## 描述

根据每日 **气温** 列表，请重新生成一个列表，
对应位置的输入是你需要再等待多久温度才会升高超过该日的天数.      
如果之后都不会升高，请在该位置用 0 来代替.

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，
输出应该是 [1, 1, 4, 2, 1, 1, 0, 0].

提示：**气温** 列表长度的范围是 [1, 30000].
每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数.

## 分析

**栈**

维护一个递减栈（不过栈元素为数组下标），
当栈顶元素对应数组中的数值小于数组当前元素时，
即此时对于栈顶元素对应的某天，数组当前下标即为温度升高的这一天.
记录.

## 代码

```cpp
vector<int> dailyTemperatures(vector<int>& T) {
    stack<int> s;
    vector<int> res(T.size(), 0);
    for (int i = 0; i < T.size(); ++i){
        while (!s.empty() && T[s.top()] < T[i]){
            res[s.top()] = i - s.top();
            s.pop();
        }
        s.push(i);
    }
    return res;
}
```

***

模拟 T = [73, 74, 75, 71, 69, 72, 76, 73].        
s = [].     
res = [0, 0, 0, 0, 0, 0, 0, 0].     
**为了便于观察，这里 s 存放数组元素.**     
res 结果为下标之差.     
***     
i = 0, T[0] = 73:      
s = [73]
***     
i = 1, T[1] = 74:      
s = [73], res = [1, 0, 0, 0, 0, 0, 0, 0], s = [74]      
***     
i = 2, T[2] = 75:      
s = [74], res = [1, 1, 0, 0, 0, 0, 0, 0], s = [75]      
***     
i = 3, T[3] = 71:      
s = [75], res = [1, 1, 0, 0, 0, 0, 0, 0], s = [75, 71]      
***     
i = 5, T[5] = 72:      
s = [75, 71, 69], res = [1, 1, 0, 0, 1, 0, 0, 0], s = [75, 71]            
s = [75, 71], res = [1, 1, 0, 2, 1, 0, 0, 0], s = [75, 72]      
***     
i = 6, T[6] = 76:      
s = [75, 72], res = [1, 1, 0, 2, 1, 1, 0, 0], s = [75]      
s = [75], res = [1, 1, 4, 2, 1, 1, 0, 0], s = [76]      
***     
i = 7, T[7] = 73:
s = [76], res = [1, 1, 4, 2, 1, 1, 0, 0], s = [76, 73]   
***

## 参考
[LeetCode-739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)