
## 描述
给定一个非空数组，数组中元素为 `a0, a1, a2, … , an-1`，
其中 `0 ≤ ai < 2^31` .

找到 `ai` 和 `aj` 最大的异或 `(XOR)` 运算结果，其中 `0 ≤ i,  j < n` .

在 *`O(n)`* 的时间解决这个问题.

## 示例

输入: [3, 10, 5, 25, 2, 8]

输出: 28

解释: 最大的结果是 5 ^ 25 = 28.

## 分析
**贪心**

~~*代码又没有看懂*~~

**先简单梳理一下**

取每个数的前缀，从高位开始，即 `mask` 依次取下值，

`1000 0000 0000 0000 0000 0000 0000 0000`

`1100 0000 0000 0000 0000 0000 0000 0000`

`...`

`1111 1111 1111 1111 1111 1111 1111 1110`

`1111 1111 1111 1111 1111 1111 1111 1111`

每一轮都会得到数组 `nums` 中所有元素当前的前缀 (**前 `i` 位**) ，将其存入 `s`.

先假设 `result` 在第 `i` 位上是 1 ，对应 `temp`.

然后遍历当前前缀集合 `s` ，~~如果 `s` 中没有 `temp` 的当前前缀~~，
如果 `temp` 与 `s` 中的某个前缀 `prefix` 异或的结果不属于 `s`，
则说明 `result` 的该位 (**第 `i` 位**) 实际值应该是 0；
否则，更新 `result = temp`，即确定 `result` 的前 `i` 位.

依次遍历 *`int`* 的 32 位，最后的 `result` 即为所求.

***

**哇，代码简单明了. tql**

从高位开始，假设 `result` 某位为 1，得到一个前缀 `temp`，
然后去匹配当前前缀集合的过程即为**贪心**.

`s` 中的某个前缀 `prefix` 与 `temp` 异或的结果在 `s` 中，
意味着 `nums` 中的两个元素可以通过异或得到前缀 `temp` (**异或性质**)，
而此时的 `temp` 是通过假设 `result` 的某位为 1 得到的.

依此，从高位开始，通过逐步确定前缀，最终就可以确定 `result `.

**异或性质**

`a XOR b = c. c XOR a = b. c XOR b = a.`

## 代码
```cpp
int findMaximumXOR(vector<int>& nums) {
    int res = 0, temp;
    int mask = 0;
    for (int i = 31; i >= 0; --i){
        mask |= (1 << i);
        set<int> s;
        for (auto num: nums)
            s.insert(mask & num);
            
        temp = res | (1 << i);
        
        for (auto prefix: s)
            if (s.find(prefix ^ temp) != s.end()){
                res = temp;
                break;
            }
    }
    return res;
}

```

### 算法复杂度
**时间复杂度**：*`O(N)`*，把整个数组看了 32 次，
即 *`O(32N) = O(N)`*.

**空间复杂度**：*`O(n)`*，这里的 `n` 是哈希表的长度，
具体长度是多少，与输入的规模、扩容策略、负载因子和冲突策略等有关.

***

## 补充

**不过该代码的效率不够高，时间只排到 10%**.

**用前缀树会快很多**.

~~*有时间再看.*~~

类似，用树存储数组元素的二进制表示，然后深度优先遍历，比较同层两个结点，
0 和 1 都出现时就需要记录.

另外，原算法中把 `set` 改为 `unordered_set` 后，
用时从 10% 提高到了 50%. 
而比用树结构慢的原因应该是在计算当前前缀时，
包含了上一次的前缀，造成了重复的计算.

## 参考
[LeetCode-421. 数组中两个数的最大异或值](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)